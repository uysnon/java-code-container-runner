5.1. Кастомная Аннотация @Auditable

java

package com.yourpackage.audit;

import java.lang.annotation.*;

@Target({ ElementType.METHOD, ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Auditable {
}

5.2. Интерсептор AuditInterceptor

java

package com.yourpackage.audit;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.util.ContentCachingRequestWrapper;
import org.springframework.web.util.ContentCachingResponseWrapper;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.nio.charset.StandardCharsets;

@Component
public class AuditInterceptor implements HandlerInterceptor {

    @Autowired
    private AuditService auditService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException {
        // Проверяем, является ли обработчик методом
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;

            // Проверяем, аннотирован ли метод или класс аннотацией @Auditable
            boolean isAuditable = handlerMethod.getMethodAnnotation(Auditable.class) != null ||
                                   handlerMethod.getBeanType().isAnnotationPresent(Auditable.class);

            if (isAuditable) {
                // Оборачиваем запрос и ответ в кэшированные версии
                ContentCachingRequestWrapper wrappedRequest = new ContentCachingRequestWrapper(request);
                ContentCachingResponseWrapper wrappedResponse = new ContentCachingResponseWrapper(response);

                // Сохраняем обернутые объекты в атрибутах запроса для доступа в afterCompletion
                request.setAttribute("wrappedRequest", wrappedRequest);
                request.setAttribute("wrappedResponse", wrappedResponse);

                return true; // Продолжаем обработку запроса
            }
        }

        return true; // Продолжаем обработку запроса без оборачивания
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws IOException {
        // Проверяем, были ли обернуты запрос и ответ
        ContentCachingRequestWrapper wrappedRequest = (ContentCachingRequestWrapper) request.getAttribute("wrappedRequest");
        ContentCachingResponseWrapper wrappedResponse = (ContentCachingResponseWrapper) request.getAttribute("wrappedResponse");

        if (wrappedRequest != null && wrappedResponse != null) {
            // Получаем тело запроса
            String requestBody = getRequestBody(wrappedRequest);

            // Получаем тело ответа
            String responseBody = getResponseBody(wrappedResponse);

            // Получаем статусный код ответа
            int statusCode = wrappedResponse.getStatus();

            // Определяем статус операции
            String status = statusCode >= 200 && statusCode < 400 ? "SUCCESS" : "ERROR";

            // Получаем сообщение об ошибке, если есть
            String errorMessage = ex != null ? ex.getMessage() : null;

            // Логируем аудит
            auditService.logAuditEvent(requestBody, responseBody, status, statusCode, errorMessage);

            // Сбрасываем кэшированный ответ, чтобы он был отправлен клиенту
            wrappedResponse.copyBodyToResponse();
        }
    }

    private String getRequestBody(ContentCachingRequestWrapper request) {
        byte[] buf = request.getContentAsByteArray();
        if (buf.length > 0) {
            return new String(buf, 0, buf.length, StandardCharsets.UTF_8);
        }
        return "";
    }

    private String getResponseBody(ContentCachingResponseWrapper response) {
        byte[] buf = response.getContentAsByteArray();
        if (buf.length > 0) {
            return new String(buf, 0, buf.length, StandardCharsets.UTF_8);
        }
        return "";
    }
}

5.3. Конфигурация WebConfig

java

package com.yourpackage.config;

import com.yourpackage.audit.AuditInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.*;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private AuditInterceptor auditInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(auditInterceptor)
                .addPathPatterns("/**"); // Применяется ко всем путям, но интерсептор сам решает, нужно ли аудировать
    }
}


package com.yourpackage.audit;

import jakarta.servlet.ServletOutputStream;
import jakarta.servlet.WriteListener;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpServletResponseWrapper;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;

public class CachedBodyHttpServletResponse extends HttpServletResponseWrapper {

    private ByteArrayOutputStream cachedBytes;
    private ServletOutputStream outputStream;
    private PrintWriter writer;

    public CachedBodyHttpServletResponse(HttpServletResponse response) {
        super(response);
        cachedBytes = new ByteArrayOutputStream();
    }

    @Override
    public ServletOutputStream getOutputStream() throws IOException {
        if (writer != null) {
            throw new IllegalStateException("getWriter() уже был вызван");
        }

        if (outputStream == null) {
            outputStream = new CachedServletOutputStream(cachedBytes);
        }
        return outputStream;
    }

    @Override
    public PrintWriter getWriter() throws IOException {
        if (outputStream != null) {
            throw new IllegalStateException("getOutputStream() уже был вызван");
        }

        if (writer == null) {
            writer = new PrintWriter(cachedBytes, true, getCharacterEncoding());
        }
        return writer;
    }

    public byte[] getCachedBytes() {
        return cachedBytes.toByteArray();
    }

    private class CachedServletOutputStream extends ServletOutputStream {

        private final ByteArrayOutputStream outputStream;

        public CachedServletOutputStream(ByteArrayOutputStream outputStream) {
            this.outputStream = outputStream;
        }

        @Override
        public void write(int b) throws IOException {
            outputStream.write(b);
        }

        @Override
        public boolean isReady() {
            return true; // Всегда готово для записи
        }

        @Override
        public void setWriteListener(WriteListener writeListener) {
            // Не требуется для синхронной записи
        }
    }
}


package com.yourpackage.audit;

import jakarta.servlet.ReadListener;
import jakarta.servlet.ServletInputStream;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletRequestWrapper;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

public class CachedBodyHttpServletRequest extends HttpServletRequestWrapper {

    private byte[] cachedBody;

    public CachedBodyHttpServletRequest(HttpServletRequest request) throws IOException {
        super(request);
        // Считываем тело запроса и сохраняем его в массив байтов
        InputStream requestInputStream = request.getInputStream();
        this.cachedBody = requestInputStream.readAllBytes();
    }

    @Override
    public ServletInputStream getInputStream() throws IOException {
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(this.cachedBody);
        return new CachedServletInputStream(byteArrayInputStream);
    }

    @Override
    public BufferedReader getReader() throws IOException {
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(this.cachedBody);
        return new BufferedReader(new InputStreamReader(byteArrayInputStream, getCharacterEncoding()));
    }

    public byte[] getCachedBody() {
        return this.cachedBody;
    }

    private class CachedServletInputStream extends ServletInputStream {

        private final ByteArrayInputStream inputStream;

        public CachedServletInputStream(ByteArrayInputStream byteArrayInputStream) {
            this.inputStream = byteArrayInputStream;
        }

        @Override
        public boolean isFinished() {
            return inputStream.available() == 0;
        }

        @Override
        public boolean isReady() {
            return true; // Всегда готово для чтения
        }

        @Override
        public void setReadListener(ReadListener readListener) {
            // Не требуется для синхронного чтения
        }

        @Override
        public int read() throws IOException {
            return inputStream.read();
        }
    }
}
